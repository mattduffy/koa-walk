<div id="map">
  <div id="container">
    <div id="login" data-tab="login">
      <form id="loginId" name="login">
        <label for="emailId">Email: </label>
        <br>
        <input type="email" id="emailId" name="email" size="40" 
          value="<%= sessionUser?.email?.primary %>" 
          placeholder="user@example.com" 
          autocomplete="email" required>
        <br>
        <br>
        <label for="passwordId">Password: </label>
        <br>
        <input type="password" id="passwordId" name="password" size="40" value="" required>
        <br>
        <input type="hidden" id="csrfTokenId" name="csrfToken" value="<%= csrfToken %>" required>
        <br>
        <input type="submit" id="submitId" name="submit" value="Login">
        <button id="cancelId" name="cancel" style="float: right;">Cancel</button>
      </form>
      <div id="welcomeId">
        <h3>Hi, <span data-name-first=""><%= sessionUser?.firstName %></span></h3>
        <form id="preferencesId" name="preferences">
          <fieldset id="set1Id" name="set1" form="preferencesId" title="User Preferences" tabindex="0">
            <legend>Preferences</legend>
            <span style="font-weight: 450;">Distance Units:</span>
            <br>
            <label>
              Metric - meters &amp; kilometers<input id="metricId" name="units" type="radio" value="Metric" <%= (preferences.units === 'Metric') ? 'checked' : '' %> tabindex="0">
            </label>
            <br>
            <label>
              Imperial - feet &amp; miles<input id="imperialId" name="units" type="radio" value="Imperial" <%= (preferences.units === 'Imperial') ? 'checked' : '' %> tabindex="0">
            </label>
            <br>
            <span style="font-weight: 450;">Map Orientation:</span>
            <br>
            <label>
              North Up<input id="northUpId" name="orientation" type="radio" value="northUp" <%= (preferences?.orientation === 'northUp') ? 'checked' : '' %> tabindex="0">
            </label>
            <br>
            <label>
              Heading Up<input id="headingUpId" name="orientation" type="radio" value="headingUp" <%= (preferences?.orientation === 'headingUp') ? 'checked' : '' %> tabindex="0">
            </label>
          </fieldset>
        </form>
        <a id="logout" href="/logout">Log out</a>
      </div>
    </div>
    <div id="list" data-tab="list">
      <div id="list-div">
        <h4>Saved Walks</h4>
        <div id="remote">
          <h5>Saved In The Cloud</h5>
        </div>
        <div id="local">
          <h5>Saved On This Device</h5>
        </div>
      </div>
      <div id="walk-div">
        <span id="closeWalk" class="close">X</span>
        <ul id="walkData">
          <li><h4 id="walkNameH4" style="font-size: .85rem;"></h4></li>
          <li><h5 id="walkLocationH5" style="font-size: .80rem;"></h5></li>
          <li>Total Distance: <span id="walkDistance" style="float: right;"></span></li>
          <li>Elapsed Time: <span id="walkDuration" style="float: right;"></span></li>
          <li>Starting Elevation: <span id="startingElevation" style="float: right;"></span></li>
          <li>Ending Elevation: <span id="endingElevation" style="float: right;"></span></li>
          <li>ùö´ Elevation: <span id="changeInElevation" style="float: right;"></span></li>
        </ul>
      </div>
    </div>
    <div id="new" data-tab="new">
      <h3>Start A New Walk</h3>
      <form id="startWalkForm" action="<%= origin %>/walk/start" method="POST">
        <input type="hidden" id="csrf-token" value="<%= csrfToken %>">
        <label for="name">Give your walk a name</label>
        <br>
        <input type="text" id="name" size=45 value="" autocomplete="off">
        <br>
        <label for="location">Location</label>
        <br>
        <input type="text" id="location" size=45 value="">
        <br>
        <label for="coords">Starting Coordinates</label>
        <br>
        <input type="text" id="coords" size=45 readonly value="">
      </form>
      <br>
      <h3 id="walkName"></h3>
      <button id="start">Start</button>
      <button id="stop" disabled>Stop</button><br>
      <div id="stats">
        Walk duration: <span id="duration">00:00:00</span><br>
        Waypoints recorded: <span id="numWaypoints">0</span><br>
        Distance walked: <span id="distance">0</span><br> 
      </div>
      <br>
      <button id="saveWalk">Save Walk</button>
      <button id="clearWalk">Clear Walk</button>
      <br>
    </div>
    <div id="maps" data-tab="maps">
      <h3>Show Maps</h3>

    </div>
    <div id="app" data-tab="app">
      <h3 id="h3"></h3>
      <p id="p1"></p>
      <p id="p2"></p>
      <p id="p3"></p>
      
    </div>
  </div>
  <div id="logging">
    <div id="bearings">
      <span id="closeLog" class="close">X</span>
      <ol id="points" reversed>
      </ol>
    </div>
  </div>
</div>
<script nonce="<%= nonce %>"
  src="https://cdn.apple-mapkit.com/mk/5.x.x/mapkit.core.js"
  crossorigin async
  data-callback="initMapKit"
  data-libraries="services,full-map,geojson,overlays"
  data-initial-token="">
</script>
<script nonce="<%= nonce %>" type="module">
  import State from '/j/State.js'
  const qParams = new URLSearchParams(window.location.search)
  const DEBUG_LEVEL = qParams.get('debug') ?? 'quiet' // 'quiet'
  const { log, info, warn, error } = await import(`./j/Logger.js?level=${DEBUG_LEVEL}`)
  info('query string level', DEBUG_LEVEL)
  info(`DEBUG LEVEL === ${DEBUG_LEVEL}`)
  let HEADING = 0
  let DISPLAY_UNITS
  let DISPLAY_ORIENTATION
  const POLYLINE_SEGEMENT_LENGTH = 10
  let VERBOSE = false
  let DEBUG = false
  DISPLAY_UNITS = <%- (preferences?.units)
    ? `\'${preferences.units}\'`
    : false %> || 'Metric'
  DISPLAY_ORIENTATION = <%- (preferences?.orientation)
    ? `\'${preferences.orientation}\'`
    : false %> || 'northUp'
  if (DEBUG_LEVEL && DEBUG_LEVEL !== 'quiet') {
    log('DEBUG_LEVEL', DEBUG_LEVEL)
    VERBOSE = true
    DEBUG = true
    if (qParams.get('units')) {
      DISPLAY_UNITS = qParams.get('units')
    }
    if (qParams.get('orientation')) {
      DISPLAY_ORIENTATION = qParams.get('orientation')
    }
  }
  info('DISPLAY_UNITS', DISPLAY_UNITS)
  info('DISPLAY_ORIENTATION', DISPLAY_ORIENTATION)
  const identifier = 'my_walk'
  const origin = '<%= origin %>'
  const jwtAccess = '<%= searchJwtAccess %>'
  window.csrfToken = '<%= csrfToken %>'
  info('csrfToken on load: ', window.csrfToken)
  window.walking = window.walking ?? new State()
  window.walker = new Worker(
    '<%= origin %>/j/worker.js',
    { name: 'walker', type: 'module' }
  ) || null
  window.walker.postMessage({ TASK: 'INIT', origin, appName: 'Walk' })
  const dMap = document.querySelector('div#map')
  const dHeader = document.querySelector('header')
  const UPDATE_INTERVAL = 1000
  const ACCURACY_INTERVAL = 10000
  const accuracy = 30 // meters
  const accuracyMargin = 5 // meters
  let lowAccuracy = false
  // let map
  const app = document.querySelector('div#app')
  function fitMap(e = {}) {
    // info('fitMap(e)', e)
    let mapHeight = window.innerHeight - dHeader.clientHeight
    dMap.style.height = `${mapHeight}px`
    dMap.style.maxHeight = `${mapHeight}px`
  }
  window.addEventListener('resize', (e) => {
    if (window.showCountBadge) {
      window.showCountBadge(
        window.walking.state.localListCache + window.walking.state.remoteListCache,
        document.querySelector('span[data-action=showList]')
      )
    }
    fitMap()
  })
  fitMap()
  document.addEventListener("readystatechange", (event) => {
    console.log(`readystate: ${document.readyState}\n`)
  })
  window.setupMapKitJs = async function() {
  // async function setupMapKitJs() {
    const tokenOpts = {
      method: 'GET',
      mode: 'same-origin',
      headers: {
        Accept: 'application/json',
        Authorization: `Bearer ${jwtAccess}`,
      },
      redirect: 'error',
    }
    info('tokenOpts', tokenOpts)
    const url = `${origin}/mapkit/getToken/`
    info('getToken url', url)
    const request = new Request(url, tokenOpts)
    const response = await fetch(request)
    let tokenID
    info('getToken response', response)
    info(response.status)
    info(response.headers.get('content-type'))
    if (response.status >= 300 && response.status < 400) {
      info(reponse.headers.get('Location'))
    } else if (response.headers.get('content-type').includes("application/json")) {
      const x = await response.json()
      tokenID = x.tokenID
      info('csrfToken before getToken: ', window.csrfToken)
      // window.csrfToken = x.newCsrfToken
      updateCsrfToken(x.newCsrfToken)
      info('csrfToken after getToken: ', window.csrfToken)
    } else {
      info('failed to get mapkit token')
      // info(await response.text())
      info('failed')
    }
    if (!window.mapkit || window.mapkit.loadedLibraries.length === 0) {
      // mapkit.core.js of the libraries are not loaded yet.
      // Set up the callback and wait for it to be called.
      await new Promise(resolve => { window.initMapKit = resolve })
      // Clean up
      delete window.initMapKit
    }
    mapkit.init({
      authorizationCallback: function(done) {
        done(tokenID)
      },
    })
  }
  window.updatePreferences = async function(e) {
    info('updatePreference(e)', e)
    e.preventDefault()
    e.stopPropagation()
    const credentials = {}
    credentials.url = `${origin}/user/preferences/update`
    credentials.csrfTokenHidden = window.csrfToken
    credentials.jwtAccess = jwtAccess
    credentials.TASK = 'SET_PREF'
    // credentials.units = e.target.value
    credentials[e.target.name] = e.target.value
    info('credentials', credentials)
    function finish(e) {
      info('updatePreferences.finish(e)', e)
      if (e.TASK === 'SET_PREF' && e.status === 'ok') {
        if (e?.newUnits) {
          DISPLAY_UNITS = e.newUnits
          window._map.distances = mapkit.Map.Distances[DISPLAY_UNITS]
        } else if (e?.newOrientation) {
          DISPLAY_ORIENTATION = e.newOrientation 
          console.log('display orientation: ', DISPLAY_ORIENTATION)
        }
      }
      if (e?.newCsrfToken) {
        // window.csrfToken = e.newCsrfToken
        updateCsrfToken(e.newCsrfToken)
      }
    }
    updatePreferences.finish = finish
    window.walker.postMessage(credentials)
  }
  async function main() {
    await setupMapKitJs()
    let position
    let lat = 39.833333 
    let lon = -98.583333
    let _alt
    let _heading
    const mapOpts = {
      distances: mapkit.Map.Distances[DISPLAY_UNITS],
      mapType: mapkit.Map.MapTypes.Standard,
      loadPriority: mapkit.Map.LoadPriorities.PointsOfInterest,
      selectableMapFeatures: [
        mapkit.MapFeatureType.PhysicalFeature,
        mapkit.MapFeatureType.PointOfInterest
      ],
      visibleMapRect: new mapkit.MapRect(0, 0, 1, 1),
      showsCompass: mapkit.FeatureVisibility.Visible,
      showsScale: mapkit.FeatureVisibility.Visible,
      showsZoomControl: true,
      showsPointsOfInterest: true,
      showsMapTypeControl: true,
      cameraDistance: 100,
      isRotationEnabled: true,
      isScrollEnabled: true,
      isZoomEnabled: true,
    }
    if ("geolocation" in navigator) {
      const geoOpts = {
        enableHighAccuracy: true,
        maximumAge: 0,
      }
      const x = await myGetCurrentPosition(geoOpts)
      info('first position fix', x)
    } else {
      info('geolocation not available, no way of knowing.')
      info(`using ${lat} ${lon} instead`)
      info('geo error: ', position)
      await noPositionCantWalk(
        mapOpts,
        { coords: {
          latitude: lat,
          longitude: lon,
          accuracy: 0,
          heading: 0,
          altitude: null,
        },
      })
    }
    function updatePosition(g) {
      info('updatePosition(g)', g)
      lat = g?.coords?.latitude ?? g.latitude
      lon = g?.coords?.longitude ?? g.longitude
      const _acc = g?.coords?.accuracy ?? g.accuracy
      const _alt = g?.coords?.altitude ?? g.altitude
      const _heading = g?.coords?.heading ?? g.heading
      if (_acc >= accuracy) {
        info(
          `position.accuracy (${_acc}) is greater than ${accuracy}m, `
          + `heading: ${_heading}, `
          + `altitude: ${_alt}`
        )
        lowAccuracy = true
      }
      const coords = {
        latitude: lat,
        longitude: lon,
        accuracy: _acc,
        altitude: _alt,
        heading: _heading,
      }
      info(coords)
      populateApp(null, coords)
      if (window.walking) {
        window.walking.currentPosition = coords
      }
    }
    async function setPosition(position) {
      info('setPosition(position)', position)
      info('window.lowAccuracy', lowAccuracy)
      if (window.walking) {
        window.walking.currentPosition = position
      }
      if (
        (lowAccuracy === undefined) &&
        (position?.coords?.accuracy > accuracy) &&
        (position?.coords?.accuracy <= accuracy + accuracyMargin)) {
        info(`low geoLocation accuracy: ${position.coords.accuracy}`)
        info('can\'t track movement very accurately.')
        await lowAccuracyPositionCantWalk(mapOpts, position)
      } else if (position && lowAccuracy) {
        info('really low geoLocation accuracy:', position)
        info('cannot track movement accurately.')
        info('mapOpts', mapOpts)
        await lowAccuracyPositionCantWalk(mapOpts, position)
      } else if (position && (lowAccuracy !== undefined && !lowAccuracy )) {
        await goodAccuracyCanWalk(mapOpts, position)
      } else {
        info('no geo position available')
        info('using lat: ', lat, ' lon: ', lon)
        await noPositionCantWalk(
          mapOpts,
          { coords: {
            latitude: lat,
            longitude: lon,
            accuracy: 1000,
            heading: 0,
            altitude: null,
          },
        })
        lowAccuracy = true
      }
    }
    window.errCount = 0
    async function accuracyUpdater() {
      if (window.walking.active) {
        log(`accuracyUpdater() error counter: ${window.errCount}`)
        if (window.errCount >= 10) {
          clearInterval(window.walking.state.accuracyUpdateInterval)
          delete window.walking.state.accuracyUpdateInterval
          log('should be undefined? ', window.walking.state?.accuracyUpdateInterval)
        } else {
          try {
            const _acc = await new Promise((res, rej) => {
              navigator.geolocation.getCurrentPosition(
                (g) => res(g.coords.accuracy),
                (e) => rej(e),
                { enableHighAccuracy: true, maximumAge: 100 }
              )
            })
            log(`updating walking state with new accuracy: ${_acc}`)
            if (typeof parseFloat(_acc) === 'number') {
              window.walking.currentPosition.accuracy = parseFloat(_acc)
            }
          } catch (e) {
            log('geolocation returned an error: ', e)
            window.errCount += 1
          } 
        }
      }
    }
    window.walking.state.accuracyUpdateInterval = setInterval(
      accuracyUpdater,
      ACCURACY_INTERVAL,
    )
    async function myGetCurrentPosition(geoOpts) {
      let position
      try {
        position = await new Promise((res, rej) => {
          navigator.geolocation.getCurrentPosition(
            (geo) => {
              if (geo.coords.accuracy > accuracy) {
                info(
                  `current position accuracy (${geo.coords.accuracy}) `
                  + `is greater than ${accuracy}m`
                )
                lowAccuracy = true
              }
              lat = geo.coords.latitude
              lon = geo.coords.longitude
              _heading = geo.coords?.heading
              _alt = geo.coords?.altitude
              res(geo)
            },
            (err) => {
              info(`code: ${err.code}, msg: ${err.message}`)
              warn(err)
              rej(err)
            },
            geoOpts
          )
        })
        // log('myGetCurrentPosition() ', position)
        // await setPosition(position)
        // updatePosition(position)
      } catch (e) {
        info('myGetCurrentPosition(): Failed to acquire geoLocation for some reason.')
        warn(e)
        info(`Falling back to generic position: lat ${lat}, lon ${lon} to initialize the map.`)
        position = {
          latitude: lat,
          longitude: lon,
          accuracy: 1000,
          heading: 0,
          altitude: null,
          timestamp: Date.now(),
        }
        lowAccuracy = undefined
        // await setPosition(position)
        // updatePosition(position)
      }
      log('myGetCurrentPosition() ', position)
      await setPosition(position)
      updatePosition(position)
      return position
    }
    window.myGetCurrentPosition = myGetCurrentPosition
    window._map.addEventListener('single-tap', mapSingleTap)
    async function mapSingleTap(e) {
      log('mapSingleTap(e)', e)
    }
    async function userLocationChange(e) {
      log('userLocationChange(e)', e)
      const isHeadingUp = document.querySelector('input#headingUpId').checked
      const evtCoords = e.coordinate
      const coords = {
        latitude: evtCoords.latitude,
        longitude: evtCoords.longitude,
        accuracy: (evtCoords?.accuracy)
          ? evtCoords.accuracy
          : window.walking.state.currentPosition.accuracy,
        altitude: evtCoords?.altitude,
        heading: evtCoords?.heading,
        timestamp: e.timestamp.valueOf()
      }
      if (!evtCoords?.altitude) {
        try {
          const position = await new Promise((res, rej) => {
            navigator.geolocation.getCurrentPosition(
              (g) => res(g.coords),
              (e) => rej(e),
              { enableHighAccuracy: true, maximumAge: 0 }
            )
          })
          coords.altitude = position?.altitude
          coords.heading = position?.heading
          info('filled in missing altitude and heading values', coords)
        } catch (e) {
          warn('failed getCurrentPosition()')
          warn('failing back to mapkit provided position, ')
          warn('which is missing altitude and heading values')
          coords.altitude = null
          coords.heading = null
        }
      }
      const mapkitCoordinate = new mapkit.Coordinate(evtCoords.latitude, evtCoords.longitude)
      if (window.walking.active) {
        await recordWalk(coords, mapkitCoordinate)
        window._map.setCenterAnimated(mapkitCoordinate, false)
      } else if (window.walking.state.showing) {
        info('showing old (saved) walk')
        return
      } else {
        window._map.setCenterAnimated(mapkitCoordinate, true)
        window.dispatchEvent(
          new CustomEvent('locality-changed', {
            bubbles: false,
            cancelable: true,
            detail: { coords },
          })
        )
      }
      info('locality-changed coords', coords)
      updatePosition(coords)
    }
    window._map.addEventListener('user-location-change', userLocationChange)
    function localityChanged(e) {
      info('localityChanged(e)', e)
      e.preventDefault()
      e.stopPropagation()
      const evtCoords = e.detail.coords
      const a = window.app || document.querySelector('div#app')
      let ol = a.querySelector('ol#change') || (() => {
        const ol = document.createElement('ol')
        ol.id = 'change'
        ol.setAttribute('reversed', '')
        a.appendChild(ol)
        return a.children.namedItem('change')
      })()
      if (e.detail.coords) {
        info('localityChanged(e) coords', e.detail.coords)
        let li = document.createElement('li')
        const heading  = 
          (window.walking.state.wayPoints[window.walking.state.wayPoints.length - 1]?.heading)
          ? window.walking.state.wayPoints[window.walking.state.wayPoints.length - 1]?.heading
          : '???'
        li.innerHTML = `lat ${evtCoords.latitude.toFixed(4)}, `
          + `lon ${evtCoords.longitude.toFixed(4)} <br>`
          + `accuracy: ${displayUnits(evtCoords.accuracy, DISPLAY_UNITS , 1)}, `
          + `heading: ${displayUnits(evtCoords.heading, 'deg', 1)}, `
          + `alt: ${evtCoords.altitude?.toFixed(1) ?? 0}`
        ol.insertBefore(li, ol.firstChild)
      }
    }
    if (DEBUG) {
      log('DEBUG=',DEBUG)
      window.addEventListener('locality-changed', localityChanged)
    }
    function clickStartNew(e) {
      info('clickStartNew(e)', e)
      e.preventDefault()
      e.stopPropagation()
      document.querySelector('span[data-action="showNew"]').click()
    }
    const showStartButton = document.querySelector('button[name="showStartNew"]')
    if (showStartButton) {
      showStartButton.addEventListener(
        'click',
        clickStartNew
      )
    }
    async function startWalk(e) {
      info('startWalk(e)', e)
      e.preventDefault()
      e.stopPropagation()
      if (!window.Worker) {
        warn('No web worker, can\'t save walk.')
        return false
      }
      if (!"geolocation" in navigator) {
        warn('You don\'t have a location, can\'t start walk.')
        return false
      }
      const startButton = document.querySelector('button#start')
      startButton.disabled = true
      const stopButton = document.querySelector('button#stop')
      stopButton.disabled = false
      const startWalkForm = document.forms.namedItem('startWalkForm')
      startWalkForm.style.display = 'none'
      const name = startWalkForm.children.namedItem('name').value
      const location = startWalkForm.children.namedItem('location').value
      const h3 = document.querySelector('h3#walkName')
      h3.textContent = name
      h3.style.display = 'block'
      function go(e) {
        info('startWalk.go(e): ', e)
      }
      startWalk.go = go
      const _d = Date.now()
      window.walking.active = true
      window.walking.startPosition = window.walking.currentPosition
      window.walking.startTime = _d
      window.walking.date = _d
      window.walking.name = name
      window.walking.location = location
      const c = new mapkit.Coordinate(
        window.walking.currentPosition.latitude,
        window.walking.currentPosition.longitude
      )
      const w = {
        TASK: 'START_WALK',
        c, 
        name,
        location,
        date: _d,
        startTime: _d,
        u: DISPLAY_UNITS,
        startPosition: window.walking.currentPosition,
        verbose: VERBOSE,
      }
      log('starting walk data:', w)
      window.walking.addPoint(
        { ...window.walking.startPosition, timestamp: _d },
        DISPLAY_UNITS, true
      )
      window.walking.c = c
      window.walker.postMessage(w)
      markWalkPointOnMap()
      window.walking.state.intervalId = setInterval(() => {
        const _p = document.querySelector('span#numWaypoints')
        _p.textContent = window.walking.points.length
        const _dur = document.querySelector('span#duration')
        const _n = Date.now() - window.walking.startTime
        _dur.textContent = new Date((_n)).toISOString().slice(11, 19)
        const _dis = document.querySelector('span#distance')
        const reducedDistance = window.walking.totalDistance
        log('reducing distances: ', reducedDistance)
        log('display formated reduced: ', displayUnits(reducedDistance, DISPLAY_UNITS, 1))
        _dis.textContent = `${displayUnits(reducedDistance, DISPLAY_UNITS, 1)}`
      }, UPDATE_INTERVAL)
    }
    document.querySelector('button#start').addEventListener('click', startWalk)
    async function recordWalk(wp, c) {
      const step = { TASK: 'SET_WAYPOINT', wp, c, u: DISPLAY_UNITS, verbose: VERBOSE }
      window.walking.c = c
      window.walking.addPoint(wp, DISPLAY_UNITS, true)
      // info(window.walking.printPoints())
      window.walker.postMessage(step)
      markWalkPointOnMap()
      updateHeading()
    }
    async function endWalk(end) {
      window.walking.active = false
      window.walking.endPosition = end
      window.walking.endTime = end.timestamp
      const c = new mapkit.Coordinate(end.latitude, end.longitude)
      const finalStep = { TASK: 'STOP_WALK', endPosition: end, c, verbose: VERBOSE }
      window.walking.addPoint(end, DISPLAY_UNITS, true)
      window.walking.c = c
      window.walker.postMessage(finalStep)
    }
    async function stopWalk(e) {
      info('stopWalk(e)', e)
      e.preventDefault()
      e.stopPropagation()
      const start = document.querySelector('button#start')
      const stop = document.querySelector('button#stop')
      start.disabled = false
      stop.disabled = true
      const startWalkForm = document.forms.namedItem('startWalkForm')
      startWalkForm.style.display = 'block'
      const coords = {
        latitude: window.walking.currentPosition.latitude,
        longitude: window.walking.currentPosition.longitude,
        accuracy: window.walking.currentPosition.accuracy,
        heading: window.walking.currentPosition.heading,
        altitude: window.walking.currentPosition.altitude,
        timestamp: Date.now(),
      }
      await endWalk(coords)
      clearInterval(window.walking.state.intervalId)
    }
    document.querySelector('button#stop').addEventListener('click', stopWalk)
    window.saveWalk = async function(e) {
      e.preventDefault()
      e.stopPropagation()
      if (window.walking.c.length === 0) {
        // No telemetry data, nothing to save.
        // Show some kind of message.
        log('nothing to save')
        return false
      }
      if (window.walking.active) {
        document.querySelector('button#stop').click()
      }
      const _name = window.walking.name
      const _date = window.walking.date
      const credentials = {
        TASK: 'SAVE_WALK',
        url: `${origin}/save`,
        csrfTokenHidden: csrfToken,
        jwtAccess: jwtAccess,
        scope: (window.isAuthenticated) ? 'remote' : 'local',
      }
      window.walker.postMessage(credentials)
      function finish(e) {
        log('finish saving walk: ', e)
        const savedWalk = { id: e.res.saved.insertedId, name: _name, date: _date }
        if (e.scope === 'remote') {
          if (!window.walking.state?.remoteListCache) {
            window.walking.state.remoteListCache = [ savedWalk ]
          } else {
            window.walking.state.remoteListCache.unshift(savedWalk)
            log(window.walking.state.remoteListCache)
          }
        } else {
          if (!window.walking.state?.localListCache) {
            window.walking.state.localListCache = [ savedWalk ]
          } else {
            window.walking.state.localListCache.unshift(savedWalk)
            log(window.walking.state.localListCache)
          }
        }
      }
      saveWalk.finish = finish
    }
    document.querySelector('button#saveWalk').addEventListener('click', saveWalk)
    function clearWalk(e) {
      e.preventDefault()
      e.stopPropagation()
      document.querySelector('span#numWaypoints').textContent = '0'
      document.querySelector('span#duration').textContent = '00:00:00'
      document.querySelector('span#distance').textContent = '0'
      document.querySelector('input[type=text]#name').value = ''
      window.walking.clear()
      window.walker.postMessage({ TASK: 'CLEAR_WALK' })
      window._map.removeOverlay(window._map.overlays.find((o) => o.data.name === identifier))
    }
    document.querySelector('button#clearWalk').addEventListener('click', clearWalk)
    function updateHeading() {
      if (DISPLAY_ORIENTATION && DISPLAY_ORIENTATION === 'northUp') {
        log('map orientation: North Up')
      } else {
        log('map orientation: Heading Up')
        let bearing
        bearing = -window.walking.lastHeading
        log(`updating heading to ${bearing} degrees off North.`)
        window._map.rotation = bearing
        if (DEBUG_LEVEL === 'verbose') {
          window.dispatchEvent(
            new CustomEvent('log-bearing', {
              bubbles: false,
              cancelable: true,
              detail: { point: window.walking.lastPoint },
            })
          )
        }
      }
    }
    function logBearing(e) {
      info('logBearing(e)', e)
      if (DEBUG_LEVEL === 'verbose') {
        info('logBearing(e)', e)
        e.preventDefault()
        e.stopPropagation()
        const p = e.detail.point
        const div = document.querySelector('div#logging')
        div.style.display = 'block'
        const ol = div.querySelector('ol#points')
        const li = document.createElement('li')
        li.textContent = `[${p.latitude}, ${p.longitude}, ${p.heading}]`
        log(li)
        ol.insertBefore(li, ol.firstChild)
      }
    }
    window.addEventListener('log-bearing', logBearing)
    document.querySelector('span#closeLog').addEventListener('click', (e) => {
      document.querySelector('ol#points')?.childNodes.forEach((li) => {
        li.remove()
      })
      document.querySelector('div#logging').style.display = 'none'
    })
    function markWalkPointOnMap() {
      log('Mark point on map: ')
      const style = new mapkit.Style({
        lineWidth: 10,
        lineJoin: 'round',
        lineDash: [],
        strokeColor: 'royalblue'
      })
      const points = window.walking.points.map((p) => {
        return new mapkit.Coordinate(p.latitude, p.longitude)
      })
      let polyline
      if (window._map.overlays.length > 0) {
        log(`${window._map.overlays.length} overlays present in map`)
        polyline = window._map.overlays.find(o => o.data.name === identifier)
        log('found previously created polyline: ', polyline)
        window._map.removeOverlay(polyline)
      }
      polyline = new mapkit.PolylineOverlay( points, { style: style })
      polyline.data = { name: identifier }
      log('creating new polyline overlay: ', polyline)
      window._map.addOverlay(polyline)
      window._map.showItems(polyline)
    }
    window.segments = []
    window.currentSegment = []
    function segmentedMarkWalkPointOnMap() {
      log('Segmented Polyline points on map')
      window.currentSegment.push(window.walking.points[window.walking.points.length - 1])
      if (window.currentSegment.length >= POLYLINE_SEGEMENT_LENGTH) {
        // make a polyline overlay segment out of currentSegment...
        // move it to the segments array...
        // empty out currentSegment
      } else {
        // just make a polyline overlay segment of currentSegment waypoints 
      }
      const style = new mapkit.Style({
        lineWidth: 7,
        lineJoin: 'round',
        lineDash: [],
        strokeColor: 'rgb(0, 122, 255)',
      })
    }
    // Feature detection for worker
    if (window.Worker) {
      log('Worker <=> Walker')
      const logged = <%= isAuthenticated %>
      const loginForm = document.forms['login']
      const cancel = loginForm.elements.cancel
      cancel.addEventListener('click', (e) => {
        const pass = document.querySelector('span#wrongPassword')
        if (pass) {
          pass.remove()
        }
        const email = document.querySelector('span#wrongEmail')
        if (email) {
          email.remove()
        }
        loginForm.elements.email.value = ''
        loginForm.elements.password.value = ''
      })
      const login = loginForm.elements.submit
      login.addEventListener('click', (e) => {
        e.preventDefault()
        e.stopPropagation()
        doLogin(document.forms['login'])
      })
      const welcomeDiv = document.querySelector('div#welcomeId')
      log(`logged = ${logged}`)
      if (logged) {
        welcomeDiv.style.display = 'block'
        loginForm.style.display = 'none'
        document.forms['preferences'].elements['units'].forEach((r) => {
          r.addEventListener('change', updatePreferences)
        })
        document.forms['preferences'].elements['orientation'].forEach((r) => {
          r.addEventListener('change', updatePreferences)
        })
      }
      const logout = document.querySelector('a#logout')
      logout.addEventListener('click', (e) => {
        e.preventDefault()
        e.stopPropagation()
        doLogout()
      })
      window.walker.onmessage = function(e) {
        log('walker.onmessage: ', e.data)
        switch (e.data.TASK) {
          case 'SETUP':
            log('csrfToken before SETUP: ', window.csrfToken)
            log(e.data)
            if (e.data?.newCsrfToken) {
              updateCsrfToken(e.data.newCsrfToken)
            }
            log('csrfToken after SETUP: ', window.csrfToken)
            break
          case 'LOGIN':
            log('csrfToken before LOGIN: ', window.csrfToken)
            // if (/failed/i.test(e.data.user.status)) {
            if (/failed/i.test(e.data?.cause?.status)) {
              // doLogin.failed(e.data.user)
              doLogin.failed(e.data.cause)
            } else {
              doLogin.success(e.data.user)
            }
            log('csrfToken after LOGIN: ', window.csrfToken)
            break
          case 'LOGOUT':
            log('csrfToken before LOGOUT: ', window.csrfToken)
            doLogout.finish(e.data)
            log('csrfToken after LOGOUT: ', window.csrfToken)
            break
          case 'GET_LIST':
            log('csrfToken before GET_LIST: ', window.csrfToken)
            window.getList.finish(e.data)
            log('csrfToken after GET_LIST: ', window.csrfToken)
            break
          case 'GET_WALK':
            log('csrfToken before GET_WALK: ', window.csrfToken)
            window.showWalk.finish(e.data)
            log('csrfToken after GET_WALK: ', window.csrfToken)
            break
          case 'EXPORT_WALK':
            log('csrfToken before EXPORT_WALK: ', window.csrfToken)
            window.exportWalkAs.finish(e.data)
            log('csrfToken after EXPORT_WALK: ', window.csrfToken)
            break
          case 'SET_PREF':
            log('csrfToken before SET_PREF: ', window.csrfToken)
            window.updatePreferences.finish(e.data)
            log('csrfToken after SET_PREF: ', window.csrfToken)
            break
          case 'START':
            log('csrfToken before START_WALK: ', window.csrfToken)
            startWalk.go(e.data)
            log('csrfToken after START_WALK: ', window.csrfToken)
            break
          case 'SAVE':
            log('csrfToken before SAVE: ', window.csrfToken)
            window.saveWalk.finish(e.data)
            log('csrfToken after SAVE: ', window.csrfToken)
            break
          case 'DELETE':
            log('csrfToken before DELETE_WALK: ', window.csrfToken)
            window.deleteWalk.finish(e.data) 
            log('csrfToken after DELETE_WALK: ', window.csrfToken)
            break
          default:
            log(e.data)
        }
      }
      window.walker.onerror = function(e) {
        e.preventDefault()
        console.warn('err msg: ', e.message)
        console.warn('in: ', e.filename)
        console.warn('at: ', e.lineno)
      }
      log('DOMContentLoaded: checking if refresh is necessary...')
      window.isAuthenticated = <%= (isAuthenticated) ? true : false %>
      log('isAuthenticated? ', isAuthenticated)
      log('window.walker: ', window.walker)
      if (window.isAuthenticated && window.walker) {
        log('refreshing user...')
        const msg = {
          TASK: 'SETUP',
          isAuth: true,
          url: `${origin}/user/refresh`,
          jwtAccess: '<%= searchJwtAccess %>',
          csrfTokenHidden: window.csrfToken,
        }
        log(msg)
        window.walker.postMessage(msg)
      }
    } else {
      warn('Not compatible with walking.')
    }
  }
  function doLogin(form) {
    const credentials = {}
    credentials.url = `${origin}/login`
    const csrfTokenHidden = form.elements['csrfToken']
    if (csrfTokenHidden.value === '' || csrfTokenHidden.value === undefined) {
      return isRequired(csrfTokenHidden)
    }
    credentials.csrfTokenHidden = csrfTokenHidden.value
    const email = form.elements['email']
    log(email)
    if (email.value === '' || email.value === undefined) {
      log(email)
      return isRequired(email)
    }
    credentials.email = email.value
    const password = form.elements['password']
    if (password.value === '' || password.value === undefined) {
      return isRequired(password)
    }
    credentials.password = password.value
    credentials.jwtAccess = jwtAccess
    credentials.TASK = 'LOGIN'
    log('1', credentials)
    function isRequired(el) {
      log(el) 
      el.style.border = '1px solid red'
      el.addEventListener('change', (e) => {
        e.target.style.border = ''
        removeEventListener('change', e.target)
      })
      return false
    }
    function success(e) {
      log('login success')
      log(e)
      // window.csrfToken = e.user.newCsrfToken
      updateCsrfToken(e.user.newCsrfToken)
      const initials = document.querySelector('span[data-name-initials]')
      const i = `${e.user.first.slice(0, 1)}${e.user.last.slice(0, 1)}`
      initials.dataset.nameInitials = i
      initials.textContent = i
      const first = document.querySelector('span[data-name-first]')
      first.dataset.first = e.user.first
      first.textContent = e.user.first
      document.querySelector(`input[type=radio][value=${
        e.user.preferences.units
      }]`).checked = 'checked'
      document.querySelector(`input[type=radio][value=${
        e.user.preferences.orientation
      }]`).checked = 'checked'
      toggleTab('login')
      form.style.display = 'none'
      const welcome = document.querySelector('div#welcomeId')
      welcome.style.display = 'block'
      toggleButtons('showLogin')
    }
    doLogin.success = success
    function failed(e) {
      if (e?.error?.match(/wrong password/i)) {
        form.elements.password.style.border = '1px solid red'
        const span = document.createElement('span')
        span.id = 'wrongPassword'
        span.textContent = e.error
        span.style.color = 'red'
        span.style.display = 'inline-block'
        span.style.fontSize = '.85em'
        form.elements.password.after(span)
      }
      if (e?.info?.match(/no user found with email/i)) {
        form.elements.email.style.border = '1px solid red'
        const span = document.createElement('span')
        span.id = 'wrongEmail'
        span.textContent = e.info
        span.style.color = 'red'
        span.style.display = 'inline-block'
        span.style.fontSize = '.85em'
        form.elements.email.after(span)
      }
      log('login failed')
      log(e)
      // window.csrfToken = e.user.newCsrfToken  
      // window.csrfToken = e.newCsrfToken  
      updateCsrfToken(e.newCsrfToken)
    }
    doLogin.failed = failed
    window.walker.postMessage(credentials)
  }
  function doLogout() {
    const form = document.forms['login']
    form.elements.password.value = ''
    form.elements.email.value = ''
    window.walker.postMessage({ TASK: 'LOGOUT', url: `${origin}/logout`, jwtAccess })
    function finish(e) {
      log('logout response: ', e)
      // window.csrfToken = e.response.user.newCsrfToken
      updateCsrfToken(e.response.user.newCsrfToken)
      delete window.walking.state.remoteListCache
      const initials = document.querySelector('span[data-name-initials]')
      initials.dataset.nameInitials = ''
      initials.textContent = ''
      const first = document.querySelector('span[data-name-first]')
      first.dataset.nameFirst = ''
      first.textContent = ''
      const walkList = document.querySelector('ul#walks')
      if (walkList) {
        walkList.remove()
      }
      toggleTab('login')
      toggleButtons('showLogin')
      form.style.display = 'block'
      const welcome = document.querySelector('div#welcomeId')
      welcome.style.display = 'none'
      // window.csrfToken = e.response.user.csrfToken
      updateCsrfToken(e.response.user.csrfToken)
    }
    doLogout.finish = finish
  }
  window.getList = async function() {
    const DIV = document.querySelector('div#list')
    const LISTDIV = DIV.querySelector('div#list-div')
    const REMOTEDIV = LISTDIV.querySelector('div#remote')
    const LOCALDIV = LISTDIV.querySelector('div#local')
    const credentials = {}
    credentials.url = `${origin}/getList`
    credentials.csrfTokenHidden = window.csrfToken
    credentials.jwtAccess = jwtAccess
    credentials.TASK = 'GET_LIST'
    credentials.scope = (window.isAuthenticated) ? 'both' : 'local'
    log(credentials)
    if (window.walking.state.showing) {
      log('go back to showing walk instead of list.')
      const WALKDIV = document.querySelector('div#walk-div')
      WALKDIV.style.display = 'block'
      log(WALKDIV)
      LISTDIV.style.display = 'none'
      log(LISTDIV)
    } else {
      if (
        (!window.walking.state.remoteListCache && window.isAuthenticated) ||
        !window.walking.state?.localListCache) {
        window.walker.postMessage(credentials)
      } else {
        renderLists()
      }
    }
    function clearCache() {
      delete window.walking.state?.remoteListCache
      delete window.walking.state?.localListCache
    }
    getList.clearCache = clearCache
    function renderLists() {
      let total = 0
      const remoteList = window.walking.state?.remoteListCache ?? []
      const remoteWalks = REMOTEDIV.children.namedItem('remote-walks') || (() => {
        const ul = document.createElement('ul')
        ul.id = 'remote-walks'
        REMOTEDIV.appendChild(ul)
        // log(ul)
        return REMOTEDIV.children.namedItem('remote-walks')
      })()
      if (!window.isAuthenticated && !document.querySelector('p#noAuth')) {
        REMOTEDIV.children.namedItem('remote-walks').remove()
        const noAuthP = document.createElement('p')
        noAuthP.id = 'noAuth'
        noAuthP.textContent = 'Login to see cloud saved walks.' 
        REMOTEDIV.appendChild(noAuthP)
      } else if (remoteWalks.children.length !== remoteList.length) {
        const noWalks = REMOTEDIV.children.namedItem('noWalks')
        if (noWalks) {
          noWalks.remove()
        }
        const replaceLis = []
        total += remoteList.length
        remoteList.forEach((w) => {
          // log(w)
          const li = document.createElement('li')
          // li.style.marginLeft = '-1.5em'
          // li.style.padding = '5px 0px 6px 0px'
          const fmt = {year: 'numeric', month: 'short', day: 'numeric'}
          li.innerHTML = `<span data-show-id="${w.id}" data-scope="remote" class="pointer">`
            + `${w.name}</span> `
            + `(${new Date(w.date).toLocaleString('en-US', fmt)}) <br>`
            + 'export: '
            + `<span data-export-id=${w.id} data-type="kml" data-scope="remote" `
            + 'class="pointer export tiny">KML</span>'
            + `<span data-export-id=${w.id} data-type="gpx" data-scope="remote" `
            + 'class="pointer export tiny">GPX</span>'
            + `<span data-export-id=${w.id} data-type="geojson" data-scope="remote" `
            + 'class="pointer export tiny">GEOJson</span>'
            + `<span data-delete-id=${w.id} data-scope="remote" class="pointer delete tiny">`
            + `delete</span>`
          replaceLis.push(li)
        })
        remoteWalks.replaceChildren(...replaceLis)
      }
      const localList = window.walking.state?.localListCache ?? []
      total += localList.length
      // log('localList', localList)
      // log('localList.length', localList.length)
      if (localList.length === 0) {
        const noLocalWalks = document.querySelector('p#noLocalWalks') ?? (() => {
          const removeLocalWalks = LOCALDIV.children.namedItem('local-walks')
          if (removeLocalWalks) {
            removeLocalWalks.remove()
          }
          const p = document.createElement('p')
          p.textContent = 'No walks saved to this device.'
          p.id = 'noLocalWalks'  
          log('p', p)
          LOCALDIV.appendChild(p) 
          return LOCALDIV 
        })()
      } else {
        const localWalks = LOCALDIV.children.namedItem('local-walks') || (() => {
          const ul = document.createElement('ul')
          ul.id = 'local-walks'
          LOCALDIV.appendChild(ul)
          // log(ul)
          return LOCALDIV.children.namedItem('local-walks')
        })()
        const noLocalWalks = LOCALDIV.children.namedItem('noLocalWalks')
        if (noLocalWalks) {
          noLocalWalks.remove()
        }
        if (localWalks.children.length !== localList.length) {
          const replaceLis = []
          localList.forEach((w) => {
            // log(w)
            const li = document.createElement('li')
            // li.style.marginLeft = '-1.5em'
            // li.style.padding = '5px 0px'
            const fmt = {year: 'numeric', month: 'short', day: 'numeric'}
            li.innerHTML = `<span data-show-id="${w.id}" data-scope="local" class="pointer">`
              + `${w.name}</span> `
              + `(${new Date(w.date).toLocaleString('en-US', fmt)}) <br>`
              + 'export: '
              + `<span data-export-id=${w.id} data-type="kml" data-scope="local" `
              + 'class="pointer export tiny">KML</span>'
              + `<span data-export-id=${w.id} data-type="gpx" data-scope="local" `
              + 'class="pointer export tiny">GPX</span>'
              + `<span data-export-id=${w.id} data-type="geojson" data-scope="local" `
              + 'class="pointer export tiny">GEOJson</span>'
              + `<span data-delete-id=${w.id} data-scope="local" class="pointer delete tiny">`
              + `delete</span>`
            replaceLis.push(li)
          })
          localWalks.replaceChildren(...replaceLis)
        } 
      }
      log(`total number of walks: ${total}`)
      if (total > 0) {
        window.showCountBadge(total, document.querySelector('span[data-action=showList]'))
      }
      document.querySelectorAll('span[data-delete-id]').forEach((s) => {
        s.addEventListener('click', deleteWalk)
      })
      document.querySelectorAll('span[data-show-id]').forEach((s) => {
        s.addEventListener('click', showWalk)
      })
      document.querySelectorAll('span[data-export-id]').forEach((s) => {
        s.addEventListener('click', exportWalkAs)
      })
    }
    window.showCountBadge = function(n = 0, el = null) {
      if (n === 0 || el === null) return
      const l = window.walking.state?.localListCache ?? {length: 0}
      const r = window.walking.state?.remoteListCache ?? {length: 0}
      const t = l.length + r.length
      log(
        `localListCache: ${l.length} + `
        + `remoteListCache: ${r.length} = ${l.length + r.length}`
      )
      const listTabIconRect = el.getBoundingClientRect() ?? {x: 0, y: 0}
      const badge = el.parentNode.querySelector('div.countBadge') || (() => {
        const div = document.createElement('div')
        div.classList.add('countBadge')
        div.style.display = 'inline-flex'
        el.after(div)
        log('created', div)
        return div
      })()
      badge.style.top = `${listTabIconRect.y + 1}px`
      badge.style.left = `${listTabIconRect.x + 42}px`
      badge.innerText = (t < 10) ? ` ${t} ` : `${t}`
    }
    window.getList.renderLists = renderLists
    function finish(e) {
      log('getList.finish', e)
      // window.csrfToken = e.newCsrfToken
      updateCsrfToken(e.newCsrfToken)
      const noAuth = LISTDIV.children.namedItem('noAuth') ?? null
      if (e.auth === 'no' && !noAuth) {
        log(`e.auth: ${e.auth}`)
        log(`noAuth: ${noAuth}`)
        const noAuthP = document.createElement('p')
        noAuthP.id = 'noAuth'
        noAuthP.textContent = 'Login to see cloud saved walks.'
        LISTDIV.children.namedItem('remote').appendChild(noAuthP)
      } else if (
        e.auth === 'no' &&
        LISTDIV.children.namedItem('remote').children.namedItem('noAuth')) {
        log('show noAuth')
        noAuth.style.display = 'block' 
      } else if (e.remoteList.length === 0) {
        log(`e.remoteList.length = ${e.remoteList.length}`)
        if (noAuth) {
          noAuth.style.display = 'none'
        }
        if (REMOTEDIV.children.namedItem('noWalks')) {
          console.log('already displayed no walks')
        } else {
          const noWalks = document.createElement('p')
          noWalks.textContent = 'No saved walks.'
          noWalks.id = 'noWalks'
          LISTDIV.children.namedItem('remote').appendChild(noWalks)
        }
      } else {
        log(`e.auth = ${e.auth} && `
          + `e.remoteList.length = ${e.remoteList.length} `
          + `e.localList.length = ${e.localList.length}`
        )
        window.walking.state.remoteListCache = e.remoteList.map((w) => {
          return {
            id: w._id,
            name: w.features[0].properties.name,
            date: w.features[0].properties.date,
          }
        })
        // renderLists() 
      }
      window.walking.state.localListCache = e.localList.map((w) => {
        return {
          id: w._id,
          name: w.features[0].properties.name,
          date: w.features[0].properties.date,
        }
      })
      // log('localListCache', window.walking.state.localListCache)
      renderLists() 
    }
    getList.finish = finish
  }
  window.showWalk = async function(e) {
    e.preventDefault()
    e.stopPropagation()
    const _id = e.target.dataset.showId
    log('showWalk(e)', e.target.dataset)
    const divList = document.querySelector('div#list-div')
    const divWalk = document.querySelector('div#walk-div')
    if (window.walking.state.show) {
      log('divList.style.display', divList.style.display)
      divList.style.display = 'none'
      log('divList.style.display', divList.style.display)
      log('divWalk.style.display', divWalk.style.display)
      divWalk.style.display = 'block'
      log('divWalk.style.display', divWalk.style.display)
    } else {
      const credentials = {
        TASK: 'GET_WALK',
        url: `${origin}/getWalk`,
        jwtAccess,
        id: e.target.dataset.showId,
        csrfTokenHidden: window.csrfToken,
        scope: e.target.dataset.scope,
      }
      window.walker.postMessage(credentials)
    }
    function finish(e) {
      log(e.walk)
      document.querySelector('h4#walkNameH4').textContent = 
        e.walk.features[0].properties.name
      document.querySelector('h5#walkLocationH5').textContent = 
        e.walk.features[0].properties.location
      document.querySelector('span#walkDistance').textContent = `${displayUnits(
        e.walk.features[0].properties.distance,
        DISPLAY_UNITS
      )}`
      document.querySelector('span#walkDuration').textContent = `${
        new Date(e.walk.features[0].properties.duration)
        .toISOString().slice(11, 19)
      }`
      document.querySelector('span#startingElevation').textContent = `${
        displayUnits((e.walk.features[0].properties.startPosition.altitude)
          ? e.walk.features[0].properties.startPosition.altitude
          : 'N/A',
          DISPLAY_UNITS
      )}`
      document.querySelector('span#endingElevation').textContent = `${
        displayUnits((e.walk.features[0].properties.endPosition?.altitude)
          ? e.walk.features[0].properties.endPosition.altitude
          : 'N/A',
          DISPLAY_UNITS
      )}`
      document.querySelector('span#changeInElevation').textContent = `${
        displayUnits(e.walk.features[0].properties.highestElevation
          - e.walk.features[0].properties.lowestElevation,
          DISPLAY_UNITS
      )}`
      divList.style.display = 'none'
      divWalk.style.display = 'block'
      window.walking.active = false 
      window.walking.state.showing = true
      window._map.showsUserLocation = false
      window.mapkit.importGeoJSON(e.walk, {
        itemForFeature: (overlay, geo) => {
          log(geo)
          overlay.data = {
            type: 'walk',
            name: geo.properties.name,
            id: _id,
          }
          overlay.style = new window.mapkit.Style({
            lineWidth: 10,
            lineJoin: "round",
            lineDash: [],
            strokeColor: "royalblue"
          })
          return overlay
        },
        geoJSONDidComplete: (overlays) => {
          window._map.showItems(overlays)
        },
      })
      const startAnnotation = new window.mapkit.MarkerAnnotation(
        new window.mapkit.Coordinate(
          e.walk.features[0].properties.startPosition.latitude,
          e.walk.features[0].properties.startPosition.longitude,
        ), {
          glyphImage: { 1: `${origin}/i/start-flag-20x20.png` },
          glyphText: 'Start',
          glyphColor: 'white',
          color: 'green',
        }
      )
      startAnnotation.animates = false 
      startAnnotation.data.type = 'walk'
      const finishAnnotation = new window.mapkit.MarkerAnnotation(
        new window.mapkit.Coordinate(
          e.walk.features[0].properties.endPosition.latitude,
          e.walk.features[0].properties.endPosition.longitude,
        ), {
          glyphImage: { 1: `${origin}/i/finish-flag.png` },
          glyphText: 'Finish',
          glyphColor: '#FFFFFF',
          color: '#000000',
        }
      )
      finishAnnotation.animates = false
      finishAnnotation.data.type = 'walk' 
      window._map.addAnnotations([ startAnnotation, finishAnnotation ])
    }
    window.showWalk.finish = finish
    function reset() {
      log('clearing walk')
      divList.style.display = 'block'
      divWalk.style.display = 'none'
      window.walking.active = false 
      window.walking.state.showing = null
      window._map.showsUserLocation = true
      window._map.removeOverlays(window._map.overlays.filter((o) => o.data.type === 'walk'))
      window._map.removeAnnotations(window._map.annotations.filter((o) => o.data.type === 'walk'))
    }
    window.showWalk.reset = reset
    document.querySelector('span#closeWalk').addEventListener('click', (e) => {
      reset()
    })
  }
  window.deleteWalk = async function(e) {
    e.preventDefault()
    e.stopPropagation()
    log(e.target.dataset)
    const credentials = {
      TASK: 'DELETE_WALK',
      url: `${origin}/delete`,
      jwtAccess,
      id: e.target.dataset.deleteId,
      csrfTokenHidden: window.csrfToken,
      scope: e.target.dataset.scope,
    }
    window.walker.postMessage(credentials)
    function finish(e) {
      log(e)
      // window.csrfToken = e.newCsrfToken
      updateCsrfToken(e.newCsrfToken)
      if (e.scope === 'remote') { 
        window._temp = window.walking.state.remoteListCache.filter((w) => {
          return w.id !== e.id
        })
        window.walking.state.remoteListCache = window._temp
      } else {
        window._temp = window.walking.state.localListCache.filter((w) => {
          return w.id !== e.id
        })
        window.walking.state.localListCache = window._temp
      }
      log(window._temp)
      delete window._temp
      window.getList.renderLists()
    }
    window.deleteWalk.finish = finish
  }
  window.exportWalkAs = async function(e) {
    e.preventDefault()
    e.stopPropagation()
    log('exportWalkAs(e)', e)
    const format = e.target.dataset.type
    const credentials = {
      TASK: 'EXPORT_WALK',
      url: `${origin}/getWalk`,
      csrfTokenHidden: window.csrfToken,
      id: e.target.dataset.exportId,
      scope: e.target.dataset.scope,
      format,
      jwtAccess,
    }
    info('export walk as', credentials)
    window.walker.postMessage(credentials)
    function finish(e) {
      log('exportWalkAs().finish(e)', e)
      // window.csrfToken = e.newCsrfToken
      updateCsrfToken(e.newCsrfToken)
      log('export data type', e) 
      const a = document.createElement('a')
      let blob
      if (format === 'kml') {
        blob = new Blob([e.kml], { type: 'application/vnd.google-earth.kml+xml' })
        a.id = 'KML-download'
      } else if (format === 'gpx') {
        blob = new Blob([e.gpx], { type: 'application/gpx+xml' })
        a.id = 'GPX-download'
      } else if (format === 'geojson') {
        blob = new Blob([e.geojson], { type: 'application/json' })
        a.id = 'GEOJson-download'
      }
      a.setAttribute('download', e.filename)
      a.setAttribute('href', window.URL.createObjectURL(blob))
      a.click()
      a.remove()
    }
    window.exportWalkAs.finish = finish
  }
  async function noPositionCantWalk(o, g) {
    log('using fallback position: ', g)
    window.me = new mapkit.Coordinate(g.coords.latitude, g.coords.longitude)
    window.here = new mapkit.CoordinateRegion(
      me,
      new mapkit.CoordinateSpan(0.05, 0.05)
    )
    if (!window._map) {
      window._map = new mapkit.Map('map', o)
    }
    window._map.region = here
    window._map.cameraDistance = 2500000
    log(`map.showsUserLocation: ${window._map.showsUserLocation}`) 
    window._map.showsUserLocation = true 
    window._map.setCenterAnimated(me, true)
    const strings = {
      h3: 'You have no location.',
      p1: 'Your walk can not be recorded.',
      p2: '',
      p3: '',
    }
    populateApp(strings)
    app.style.display = 'block'
  }  
  async function lowAccuracyPositionCantWalk(o, g) {
    log(`low accuracy: ${g.coords.accuracy}`)
    o.showsUserLocationControl = true
    o.tracksUserLocation = true
    window.me = new mapkit.Coordinate(g.coords.latitude, g.coords.longitude)
    window.here = new mapkit.CoordinateRegion(
      me,
      new mapkit.CoordinateSpan(0.05, 0.05)
    )
    if (!window._map) {
      window._map = new mapkit.Map('map', o)
    }
    window._map.region = here
    if (10 * (accuracy + accuracyMargin) <= (Math.trunc(g.coords.accuracy))) {
      log('really low accuracy', Math.trunc(g.coords.accuracy))
      window._map.cameraDistance = Math.trunc(g.coords.accuracy) * 10
    } else {
      window._map.cameraDistance = 100
    }
    window._map.showsUserLocation = true 
    log(`map.showsUserLocation: ${window._map.showsUserLocation}`) 
    window._map.setCenterAnimated(me, true)
    myGeocoder(me)
    const strings = {
      h3: `Can't get a very accurate GPS position.`,
      p1: 'Your position is '
        + `<span id="lat" class="coords">lat ${g.coords.latitude.toFixed(4)}</span>, `
        + `<span id="lon" class="coords">lon ${g.coords.longitude.toFixed(4)}</span>.<br>`,
      p2: '<span id="alt" class="coords">Your altitude is '
        + `${displayUnits(g.coords?.altitude, DISPLAY_UNITS, 1)}</span>`
        + ', <span id="heading" class="coords">heading '
        + `${displayUnits(g.coords?.heading, 'deg', 1)}<span>.<br>`,
      p3: 'GPS accuracy is low, <span id="acc" class="coords">'
        + `${displayUnits(g.coords.accuracy, DISPLAY_UNITS, 1)}</span>.<br>`
        + `Your walk may not be recorded very accurately.`,
      b1: '<button name="showStartNew">Start a walk!</button>',
    }
    populateApp(strings)
    app.style.display = 'block'
  }
  async function goodAccuracyCanWalk(o, g) {
    log(`good accuracy: ${g.coords.accuracy}`)
    o.showsUserLocation = true
    o.tracksUserLocation = true
    o.showsUserLocationControl = true
    window.me = new mapkit.Coordinate(g.coords.latitude, g.coords.longitude)
    window.here = new mapkit.CoordinateRegion(
      me,
      new mapkit.CoordinateSpan(0.05, 0.05)
    )
    if (!window._map) {
      window._map = new mapkit.Map('map', o)
    }
    window._map.region = here
    window._map.cameraDistance = 100
    window._map.showsUserLocation = true 
    window._map.setCenterAnimated(me, true)
    myGeocoder(me) 
    const strings = {
      h3: 'Your starting position looks good.',
      p1: 'Your position is '
        + `<span id="lat" class="coords">lat ${g.coords.latitude.toFixed(4)}</span>, `
        + `<span id="lon" class="coords">lon ${g.coords.longitude.toFixed(4)}</span><br>`,
      p2: '<span id="alt" class="coords">Your altitude is '
        + `${displayUnits(g.coords?.altitude, DISPLAY_UNITS, 1)}</span>`
        + ', <span id="heading" class="coords">heading '
        + `${displayUnits(g.coords?.heading, 'deg', 1)}</span>.<br>`,
      p3: 'GPS accuracy is good, <span id="acc" class="coords">'
        + `${displayUnits(g.coords.accuracy, DISPLAY_UNITS, 1)}`
        + '</span>.<br>'
        + 'Tap the start button when you are ready.',
      b1: '<button name="showStartNew">Start a walk!</button>',
    }
    populateApp(strings)
    app.style.display = 'block'
  }
  // Geocoder
  function myGeocoder(coords) {
    log('geocoder with: ', coords)
    const opts = {
      getsUserLocation: true,
      language: 'en-US'
    }
    const geocoder = new mapkit.Geocoder(opts)
    log(geocoder)
    const reverseLookup = geocoder.reverseLookup(coords, function(error, data) {
      log('reverseLookup callbback')
      if (error) {
        warn(error)
      }
      if (data && data.results.length > 0) {
        log(data.results[0])
        populateApp(null, null, data.results[0])
      }
    })
  }
  function displayUnits(x, u = 'm', n = 1) {
    const _u = u.toLowerCase()
    log('displayUnits(): ', x, _u, n)
    let _x
    if (isNaN(x)) {
      _x = 'N/A'
    } else if (x === null || x === undefined) {
      log('displayUnits() missing x: ', x)
      _x = 'indeterminate' 
    } else {
      _x = x
    }
    if (/(deg(rees)?)|(¬∞)/i.test(_u)) {
      if (isNaN(_x)) {
        return `${_x}¬∞`
      } else {
        return `${_x.toFixed(1)}¬∞`
      }
    }
    if (/(metric)|(km)|(m$)/i.test(_u)) {
      if (_x < 750) {
        return `${_x.toFixed(n)} m`
      } else {
        return `${( parseFloat(_x) / 1000 ).toFixed(n)} km`
      }
    } else if (/(imperial)|(mile)|(mi)|(feet)|(ft)|(f)/i.test(_u)) {
      let _x = parseFloat(x) * 3.3
      if (_x < (5280 / 2)) {
        return `${_x.toFixed(n)} ft`
      } else {
        return `${( _x / 5280 ).toFixed(n)} mi`
      }
    }
    return 'indeteriminate'
  }
  function populateApp(strings, coords = null, theLocality = null) {
    const a = window.app ?? document.querySelector('div#app')    
    // log(a)
    if (strings) {
      a.children.namedItem('h3').innerHTML = strings.h3
      a.children.namedItem('p1').innerHTML = strings.p1
      a.children.namedItem('p2').innerHTML = strings.p2
      a.children.namedItem('p3').innerHTML = strings.p3
      if (strings?.b1) {
        const b1div = document.createElement('div')
        b1div.innerHTML = strings.b1
        a.appendChild(b1div)
      }
    }
    if (theLocality) {
      const {
        subLocality,
        name,
        locality,
        administrativeArea,
        administrativeAreaCode,
      } = theLocality ?? null
      log(`updating new locality: ${(subLocality) ? subLocality + ',' : ''} ${name}`)
      const l = `${(subLocality) ? '<span id="subLocality">' + subLocality + '</span><br>' : ''}`
        + `${(name) ? '<span id="name">' + name + '</span><br>' : ''}` 
        + `${(locality) ? '<span id="locality">' + locality + '</span>, ' : ''}`
        + `${(administrativeAreaCode)
          ? '<span id="administrativeAC">' + administrativeAreaCode + '</span>'
          : ''}`
        + '<br>'
        a.children.namedItem('p2').innerHTML += `<br>${l}`
      // new walk div content
      if (!window.walking.active) {
        document.querySelector('input[id="name"]').value = (subLocality) ? subLocality : name
        document.querySelector('input[id="location"]').value = `${(name) ? name : ''}`
          + `${(locality) ? ', ' + locality : ''}`
          + `${(administrativeAreaCode) ? ', ' + administrativeAreaCode : ''}`
      }
    }
    if (coords) {
      log('populateApp coords: ', coords)
      log(
        `updating user's coordinates: (${coords.latitude.toFixed(4)}, `
        + `${coords.longitude.toFixed(4)})`
      )
      const _lat = a.querySelector('p > span#lat')
      if (coords.latitude && _lat) {
        a.querySelector('p > span#lat').innerHTML = `lat ${coords.latitude.toFixed(4)}`
      }
      const _lon = a.querySelector('p > span#lon')
      if (coords.longitude && _lon) {
        a.querySelector('p > span#lon').innerHTML = `lon ${coords.longitude.toFixed(4)}`
      }
      const _acc = a.querySelector('p > span#acc')
      if (coords.accuracy && _acc) {
        _acc.innerHTML = displayUnits(coords.accuracy, DISPLAY_UNITS, 1)
      }
      const _alt = a.querySelector('p > span#alt')
      if (coords?.altitude && _alt) {
        a.querySelector('p > span#alt').innerHTML = 
          // `Your altitude is ${coords?.altitude?.toFixed(1) ?? 0}`
          `Your altitude is ${displayUnits(coords?.altitude, DISPLAY_UNTIS, 1)}`
      }
      const _heading = a.querySelector('p > span#heading')
      if (coords.heading && _heading) {
        // a.querySelector('p > span#heading').innerHTML = `heading ${coords.heading}`
        a.querySelector('p > span#heading').innerHTML = 
          `heading ${displayUnits(coords.heading, 'deg', 1)}`
      }
      // new walk div content
      if (!window.walking.active) {
        document.querySelector('input[id="coords"]').value = `${coords.latitude}, `
          + `${coords.longitude}`
      }
    }
  }
  await main()
  function updateCsrfToken(token) {
    window.csrfToken = token
    document.querySelector('input[type=hidden]#csrfTokenId').value = token
  }
  window._x = async function(P) {
    window.walking.state.showing = true
    const delay = ms => new Promise(res => setTimeout(res, ms))
    let i = 0
    for await (const p of P) {
      await delay(1000)
      console.log(i, p)
      window._map.addAnnotations(
        [ new window.mapkit.MarkerAnnotation(
          new window.mapkit.Coordinate(p[0], p[1])
          ,{
            glyphText: `${i}, ${p[2]}`,
            glyphColor: 'white',
            color: 'green',
          })
        ]
      )
      window._map.setCenterAnimated(new window.mapkit.Coordinate(p[0], p[1]), false)
      window._map.rotation = p[2]
      i += 1
    }
    window.walking.state.showing = false
  }
</script>
