<div id="map">
  <div id="container">
    <div id="login" data-tab="login">
      <form id="loginId" name="login">
        <label for="emailId">Email: </label>
        <br>
        <input type="email" id="emailId" name="email" size="40" value="<%= sessionUser?.email?.primary %>" placeholder="user@example.com" required>
        <br>
        <label for="passwordId">Password: </label>
        <br>
        <input type="password" id="passwordId" name="password" size="40" value="" required>
        <br>
        <input type="hidden" id="csrfTokenId" name="csrfToken" value="<%= csrfToken %>" required>
        <input type="submit" id="submitId" name="submit" value="Login">
        <button id="cancelId" name="cancel">Cancel</button>
      </form>
      <div id="welcomeId">
        <h3>Hi, <span data-first=""><%= sessionUser?.firstName %></span></h3>
        <a id="logout" href="/logout">Log out</a>
      </div>
    </div>
    <div id="list" data-tab="list">
      <h3>Saved Walks</h3>
    </div>
    <div id="new" data-tab="new">
      <h3>Start A New Walk</h3>
      <form id="startWalkForm" action="<%= origin %>/walk/start" method="POST">
        <input type="hidden" id="csrf-token" value="<%= csrfToken %>">
        <label for="name">Give your walk a name</label>
        <input type="text" id="name" size=45 value="">
        <label for="lat">Latitude</label>
        <input type="text" id="lat" size=45 readonly value="">
        <label for="lon">Longitude</label>
        <input type="text" id="lon" size=45 readonly value="">
      </form>
      <br>
      <h3 id="walkName"></h3>
      <button id="start">Start</button>
      <button id="stop" disabled>Stop</button>
      <span id="timer"></span>

    </div>
    <div id="maps" data-tab="maps">
      <h3>Show Maps</h3>

    </div>
    <div id="app" data-tab="app">
      <h3 id="h3"></h3>
      <p id="p1"></p>
      <p id="p2"></p>
      <p id="p3"></p>
      
    </div>
  </div>
</div>
<script nonce="<%= nonce %>"
  src="https://cdn.apple-mapkit.com/mk/5.x.x/mapkit.core.js"
  crossorigin async
  data-callback="initMapKit"
  data-libraries="services,full-map"
  data-initial-token="">
</script>
<script nonce="<%= nonce %>" type="module">
  import State from '/j/State.js'
  window.geoWatch = null
  window.walking = window.walking ?? new State()
  const dMap = document.querySelector('div#map')
  const dHeader = document.querySelector('header')
  function fitMap() {
    let mapHeight = window.innerHeight - dHeader.clientHeight
    dMap.style.height = `${mapHeight}px`
    dMap.style.maxHeight = `${mapHeight}px`
  }
  window.addEventListener('resize', (e) => {
    const h = window.innerHeight
    const w = window.innerWidth
    fitMap()
  })
  fitMap()
  window.walker = new Worker('<%= origin %>/j/worker.js', { name: 'walker', type: 'module' }) || null
  window.csrfToken = '<%= csrfToken %>'
  const accuracy = 30 // meters
  const accuracyMargin = 5 // meters
  let lowAccuracy = false
  const origin = '<%= origin %>'
  const jwtAccess = '<%= searchJwtAccess %>'
  let map
  const app = document.querySelector('div#app')
  async function setupMapKitJs() {
    const tokenOpts = {
      method: 'GET',
      headers: {
        Accept: 'application/json',
        Authorization: `Bearer ${jwtAccess}`,
      },
    }
    const request = new Request(`${origin}/mapkit/getToken`, tokenOpts)
    const response = await fetch(request)
    let tokenID
    if (response.headers.get('content-type').includes("application/json")) {
      const x = await response.json()
      tokenID = x.tokenID
      console.log(`mapkit token: ${tokenID}`)
    } else {
      console.info('failed to get mapkit token')
      console.log(await response.text())
    }
    if (!window.mapkit || window.mapkit.loadedLibraries.length === 0) {
      // mapkit.core.js of the libraries are not loaded yet.
      // Set up the callback and wait for it to be called.
      await new Promise(resolve => { window.initMapKit = resolve })
      // Clean up
      delete window.initMapKit
    }
    mapkit.init({
      authorizationCallback: function(done) {
        done(tokenID)
      },
    })
  }
  async function main() {
    await setupMapKitJs()
    let lat = 39.833333 
    let lon = -98.583333
    let position
    let watchPosId
    const mapOpts = {
      // mapType: mapkit.Map.MapTypes.Hybrid,
      mapType: mapkit.Map.MapTypes.Standard,
      loadPriority: mapkit.Map.LoadPriorities.PointsOfInterest,
      selectableMapFeatures: [mapkit.MapFeatureType.PhysicalFeature, mapkit.MapFeatureType.PointOfInterest],
      visibleMapRect: new mapkit.MapRect(0, 0, 1, 1),
      isZoomEnabled: true,
      showsCompass: mapkit.FeatureVisibility.Visible,
      showsScale: mapkit.FeatureVisibility.Visible,
      showsZoomControl: true,
      cameraDistance: 100,
      showsPointsOfInterest: true,
      isRotationEnabled: true,
      isScrollEnabled: true,
      // showsMapTypeControl: false,
      showsMapTypeControl: true,
    }
    if ("geolocation" in navigator) {
      console.log('Can we get a location fix?') 
      const _opts = {
        enableHighAccuracy: true,
        timeout: 5000,
        maximumAge: 0,
      }
      // watchPosId = navigator.geolocation.watchPosition(geoSuccess, geoFail, _opts)
      async function geoSuccess(g) {
        console.log('geoSuccess')
        console.info(g)
        if (window.walking) {
          window.walking.setCurrentPosition({
            latitude: g.coords.latitude,
            longitude: g.coords.longitude,
            accuracy: g.coords.accuracy,
            timestamp: g.timestamp.valueOf(),
          })
        }
        updatePosition(g)
        // window.p = g
        position = g
        try {
          await setPosition(position)
        } catch (e) {
          console.warn(e)
        }
      }
      function geoFail(g) {
        console.info('geoFail')
        console.info(g)
      }
      const geoOpts = {
        enableHighAccuracy: true,
        maximumAge: 1000 * 3,
      }
      console.log('geo options: ', geoOpts)
      await myGetCurrentPosition(geoOpts)
    } else {
      console.log('geolocation not available, no way of knowing.')
      console.log(`using ${lat} ${lon} instead`)
      console.log('geo error: ', position)
      await noPositionCantWalk(mapOpts, { coords: { latitude: lat, longitude: lon, accuracy: 0 } })
    }
    function updatePosition(g) {
      console.log('updating position', g)
      lat = g?.coords?.latitude ?? g.latitude
      lon = g?.coords?.longitude ?? g.longitude
      const _acc = g?.coords?.accuracy ?? g.accuracy
      if (_acc > accuracy) {
        console.info(`position.accuracy (${_acc}) is greater than ${accuracy}m`)
        lowAccuracy = true
      }
      const coords = { latitude: lat, longitude: lon, accuracy: _acc}
      populateApp(null, coords)
    }
    async function setPosition(position) {
      console.log('geolocation: ', position)
      if (position && !lowAccuracy) {
        await goodAccuracyCanWalk(mapOpts, position)
      } else if (position?.coords?.accuracy > accuracy && position?.coords?.accuracy <= accuracy + accuracyMargin) {
        console.info(`low geoLocation accuracy: ${position.coords.accuracy}`)
        console.info('can\'t track movement accurately.')
        console.info(mapOpts)
        await lowAccuracyPositionCantWalk(mapOpts, position)
      } else if (lowAccuracy && position) {
        console.info(`really low geoLocation accuracy: ${position.coords.accuracy}`)
        console.info('can\'t track movement accurately.')
        console.log(mapOpts)
        await lowAccuracyPositionCantWalk(mapOpts, position)
      } else {
        console.log('no geo position available')
        console.log('using lat: ', lat, ' lon: ', lon)
        await noPositionCantWalk(mapOpts, { coords: { latitude: lat, longitude: lon, accuracy: 1000 } })
        lowAccuracy = true
      }
    }
    async function myGetCurrentPosition(geoOpts) {
      let position
      try {
        position = await new Promise((resolve, reject) => {
          navigator.geolocation.getCurrentPosition(
            (geo) => {
              if (geo.coords.accuracy > accuracy) {
                console.info(`current position accuracy (${geo.coords.accuracy}) is greater than ${accuracy}m`)
                lowAccuracy = true
              }
              lat = geo.coords.latitude
              lon = geo.coords.longitude
              resolve(geo)
            },
            (err) => {
              console.log(err)
              console.info(`code: ${err.code}, msg: ${err.message}`)
              reject(err)
            },
            geoOpts
          )
        })
        console.log('myGetCurrentPosition:: ', position)
        // window.p = position
        window.walking.setCurrentPosition(position)
        await setPosition(position)
        updatePosition(position)
      } catch (e) {
        console.warn('failed to acquire geoLocation for some reason.')
        console.warn(e)
        console.log(`Failing back to generic position: lat ${lat}, lon ${lon} to initialize the map.`)
        // window.p = { coords: { latitude: lat, longitude: lon, accuracy: 1000 } }
        window.walking.setCurrentPosition({ latitude: lat, longitude: lon, accuracy: 1000, timestamp: new Date().valueOf() })
        position = null
        lowAccuracy = null
        await setPosition(position)
      }
      return position
    }
    window.myGetCurrentPosition = myGetCurrentPosition
    window._map.addEventListener('single-tap', mapSingleTap)
    async function mapSingleTap(e) {
      console.log(e)
    }
    window._map.addEventListener('user-location-change', userLocationChange)
    async function userLocationChange(e) {
      console.log('user-location-change event: ', e)
      const coords = { latitude: e.coordinate.latitude, longitude: e.coordinate.longitude, accuracy: window.walking.state.currentPosition.accuracy, timestamp: e.timestamp.valueOf() }
      console.log(window.walking.state)
      console.log(coords)
      window.walking.setCurrentPosition(coords)
      if (!window.walking.state?.active) {
        const x = new mapkit.Coordinate(e.coordinate.latitude, e.coordinate.longitude)
        console.log(x)
        window._map.setCenterAnimated(x, true)
        updatePosition(coords)
        window.dispatchEvent(
          new CustomEvent('locality-changed', {
            bubbles: false,
            cancelable: true,
            // detail: { coords: coords.coords },
            detail: { coords },
          })
        )
      } else {
        // do walking stuff here
      }
    }
    window.addEventListener('locality-changed', localityChanged)
    function localityChanged(e) {
      e.preventDefault()
      e.stopPropagation()
      const a = window.app || document.querySelector('div#app')
      let ul = a.querySelector('ol#change')
      if (!ul) {
        ul = document.createElement('ol')
        ul.id = 'change'
        a.appendChild(ul)
      }
      if (e.detail.coords) {
        console.log(e.detail)
        let li = document.createElement('li')
        li.textContent = `lat/lon: (${e.detail.coords.latitude.toFixed(4)}, ${e.detail.coords.longitude.toFixed(4)}), acc: ${displayUnits(e.detail.coords.accuracy, 'f', 1)}`
        ul.appendChild(li)
      }

    }
    document.querySelector('button[name="showStartNew"]').addEventListener('click', clickStartNew)
    function clickStartNew(e) {
      console.log(e)
      e.preventDefault()
      e.stopPropagation()
      document.querySelector('span[data-action="showNew"]').click()
    }
    document.querySelector('button#start').addEventListener('click', startWalk)
    async function startWalk(e) {
      e.preventDefault()
      e.stopPropagation()
      if (!window.Worker) {
        console.warn('No web worker, can\'t save walk.')
        return false
      }
      if (!"geolocation" in navigator) {
        console.warn('You don\'t have a location, can\'t start walk.')
        return false
      }
      const startButton = document.querySelector('button#start')
      startButton.disabled = true
      const stopButton = document.querySelector('button#stop')
      stopButton.disabled = false
      window.walking.state.active = true
      // window._map.removeEventListener('user-location-change', userLocationChange)
      const startWalkForm = document.forms.namedItem('startWalkForm')
      startWalkForm.style.display = 'none'
      const h3 = document.querySelector('h3#walkName')
      h3.textContent = startWalkForm.children.namedItem('name').value
      h3.style.display = 'block'
      function go(e) {
        console.log('startWalk.go(): ', e)
      }
      startWalk.go = go
      const w = { startTime: Math.floor(new Date().getTime() / 1000), TASK: 'START_WALK' }
      window.walker.postMessage(w)
    }
    document.querySelector('button#stop').addEventListener('click', stopWalk)
    async function stopWalk(e) {
      e.preventDefault()
      e.stopPropagation()
      const start = document.querySelector('button#start')
      const stop = document.querySelector('button#stop')
      start.disabled = false
      stop.disabled = true
      window.walking.state.active = false
      // window._map.addEventListener('user-location-change', userLocationChange)
      const startWalkForm = document.forms.namedItem('startWalkForm')
      startWalkForm.style.display = 'block'
    }
      
    if (window.Worker) {
      console.log('Worker <=> Walker')
      const logged = <%= isAuthenticated %>
      const loginForm = document.forms['login']
      const login = loginForm.elements.submit
      login.addEventListener('click', (e) => {
        e.preventDefault()
        e.stopPropagation()
        doLogin(document.forms['login'])
      })
      const welcomeDiv = document.querySelector('div#welcomeId')
      console.log(`logged = ${logged}`)
      if (logged) {
        welcomeDiv.style.display = 'block'
        loginForm.style.display = 'none'
      }
      const logout = document.querySelector('a#logout')
      logout.addEventListener('click', (e) => {
        e.preventDefault()
        e.stopPropagation()
        doLogout()
      })
      window.walker.onmessage = function(e) {
        console.log(e.data)
        switch (e.data.TASK) {
          case 'SETUP':

            break
          case 'LOGIN':
            if (e.data.user.status === 'login failed') {
              doLogin.failed(e.data.user)
            } else {
              doLogin.success(e.data.user)
            }
            break
          case 'LOGOUT':
            doLogout.finish(e.data)
            break
          case 'GET_LIST':
            window.getList.finish(e.data)
            break
          case 'START':
            startWalk.go(e.data)
            break
          default:
            console.log(e.data)
        }
      }
      window.walker.onerror = function(e) {
        e.preventDefault()
        console.warn('err msg: ', e.message)
        console.warn('in: ', e.filename)
        console.warn('at: ', e.lineno)
      }
      

      window.walker.postMessage('What should I do?')
      const tasks = [
        // {TASK: 'START_WALK', msg: 'I am starting a walk'},
        // {TASK: 'STOP_WALK', msg: 'I am done with my walk'},
        // {TASK: 'ET_WAYPOINT', msg: `I am at position (${lat} lat, ${lon} lon).`},
        {TASK: 'SAVE_WALK', msg: 'Save this walk.'},
        {TASK: 'GET_WALK', msg: 'Get that previous walk.'},
        {TASK: 'GET_A_LIFE', msg: 'you heard me'}
      ]
      try {
        tasks.forEach(async (walk) => {
          // window.walker.postMessage(walk)
        })
      } catch (e) {
        console.warn(e)
      }
    } else {
      console.log('Not compatible with walking.')
    }   
  }
  function doLogin(form) {
    const credentials = {}
    credentials.url = `${origin}/login`
    const csrfTokenHidden = form.elements['csrfToken']
    if (csrfTokenHidden.value === '' || csrfTokenHidden.value === undefined) {
      return isRequired(csrfTokenHidden)
    }
    credentials.csrfTokenHidden = csrfTokenHidden.value
    const email = form.elements['email']
    if (email.value === '' || email.value === undefined) {
      return isRequired(email)
    }
    credentials.email = email.value
    const password = form.elements['password']
    if (password.value === '' || password.value === undefined) {
      return isRequired(password)
    }
    credentials.password = password.value
    credentials.jwtAccess = jwtAccess
    credentials.TASK = 'LOGIN'
    console.log('1', credentials)
    function isRequired(el) {
      console.log(el) 
      el.style.border = '1px solid red'
      el.addEventListener('change', (e) => {
        e.target.style.border = ''
        removeEventListener('change', e.target)
      })
      return false
    }
    function success(e) {
      console.log('login success')
      console.log(e)
      const spans = document.querySelectorAll('span[data-first]')
      spans.forEach((span) => {
        console.log(span)
        span.dataset.first = e.user.first
        span.innerText = e.user.first
      })
      toggleTab('login')
      form.style.display = 'none'
      const welcome = document.querySelector('div#welcomeId')
      welcome.style.display = 'block'
      toggleButtons('showLogin')
    }
    doLogin.success = success
    function failed(e) {
      if (e?.error?.match(/wrong password/i)) {
        form.elements.password.style.border = '1px solid red'
      }
      if (e?.info?.match(/no user found with email/i)) {
        form.elements.email.style.border = '1px solid red'
      }
      console.log('login failed')
      console.log(e)
    }
    doLogin.failed = failed
    window.walker.postMessage(credentials)
  }
  function doLogout() {
    const form = document.forms['login']
    form.elements.password.value = ''
    form.elements.email.value = ''
    window.walker.postMessage({ TASK: 'LOGOUT', url: `${origin}/logout`, jwtAccess })
    function finish(res) {
      console.log('logout response: ', res)
      const spans = document.querySelectorAll('span[data-first]')
      spans.forEach((span) => {
        console.log(span)
        span.dataset.first = ''
        span.innerText = ''
      })
      toggleTab('login')
      toggleButtons('showLogin')
      form.style.display = 'block'
      const welcome = document.querySelector('div#welcomeId')
      welcome.style.display = 'none'
      window.csrfToken = res.response.user.csrfToken
      form.elements.csrfToken.value = res.response.user.csrfToken
    }
    doLogout.finish = finish
  }
  window.getList = async function() {
    const credentials = {}
    credentials.url = `${origin}/getList`
    credentials.csrfTokenHidden = window.csrfToken
    credentials.jwtAccess = jwtAccess
    credentials.TASK = 'GET_LIST'
    console.log(credentials)
    const div = document.querySelector('div#list')
    function finish(e) {
      console.log('getList.finish', e)
      const noAuth = div.children.namedItem('noAuth') ?? null
      if (e.auth === 'no' && !noAuth) { 
        console.log(`e.auth: ${e.auth}`)
        console.log(`noAuth: ${noAuth}`)
        const noAuthP = document.createElement('p')
        noAuthP.id = 'noAuth'
        noAuthP.textContent = 'Login to see saved walks.'
        div.appendChild(noAuthP)
      } else if (div.children.namedItem('noAuth')) {
        console.log('show noAuth')
        noAuth.style.display = 'block' 
      } else if (e.list.length === 0) {
        console.log(`e.list.length = ${e.list.length}`)
        if (noAuth) {
          noAuth.style.display = 'none'
        }
        if (div.children.namedItem('noWalks')) {
          console.log('already displayed no walks')
        } else {
          const noWalks = document.createElement('p')
          noWalks.textContent = 'No saved walks.'
          noWalks.id = 'noWalks'
          div.appendChild(noWalks)
        }
      } else {
        console.log(`e.auth = ${e.auth} && e.list.length = ${e.list.length}`)
        const walks = div.children.namedItem('walks')
        if (!walks) {
          const ul = document.createElement('ul')
          ul.id = 'walks'
          e.list.forEach((w) => {
            const li = document.createElement('li')
            li.innerHTML = `${w}`
            ul.appendChild(li)
          })
          div.appendChild(ul)
        } else {
          console.log(`e.auth = ${e.auth}`)
          e.list.forEach((w) => {
            const li = document.createElement('li')
            li.textContent = `${w}`
            ul.appendChild(li)
          })
        }
      }
    }
    getList.finish = finish
    window.walker.postMessage(credentials)
  }
  async function noPositionCantWalk(o, g) {
    console.log(`no position available: ${g}`)
    window.me = new mapkit.Coordinate(g.coords.latitude, g.coords.longitude)
    window.here = new mapkit.CoordinateRegion(
      me,
      new mapkit.CoordinateSpan(0.05, 0.05)
    )
    if (!window._map) {
      window._map = new mapkit.Map('map', o)
    }
    window._map.region = here
    window._map.cameraDistance = 250000
    console.log(`map.showsUserLocation: ${window._map.showsUserLocation}`) 
    window._map.showsUserLocation = true 
    window._map.setCenterAnimated(me, true)
    const strings = {
      h3: 'You have no location.',
      p1: 'Your walk can not be recorded.',
      p2: '',
      p3: '',
    }
    populateApp(strings)
    app.style.display = 'block'
  }  
  async function lowAccuracyPositionCantWalk(o, g) {
    console.log(`low accuracy: ${g.coords.accuracy}`)
    o.showsUserLocationControl = true
    o.tracksUserLocation = true
    window.me = new mapkit.Coordinate(g.coords.latitude, g.coords.longitude)
    window.here = new mapkit.CoordinateRegion(
      me,
      new mapkit.CoordinateSpan(0.05, 0.05)
    )
    if (!window._map) {
      window._map = new mapkit.Map('map', o)
    }
    window._map.region = here
    if (Math.trunc(g.coords.accuracy) > 10 * (accuracy + accuracyMargin)) {
      console.log('really low accuracy')
      window._map.cameraDistance = Math.trunc(g.coords.accuracy)
    } else {
      window._map.cameraDistance = 100
    }
    window._map.showsUserLocation = true 
    console.log(`map.showsUserLocation: ${window._map.showsUserLocation}`) 
    window._map.setCenterAnimated(me, true)
    myGeocoder(me)
    const strings = {
      h3: `Can't get a very accurate GPS position.`,
      p1: `Your position is <span id="lat" class="coords">${g.coords.latitude.toFixed(4)}</span> lat, <span id="lon" class="coords">${g.coords.longitude.toFixed(4)}</span> lon.<br>`,
      p2: ``,
      p3: `GPS accuracy is low, <span id="acc" class="coords">${displayUnits(g.coords.accuracy, 'f', 1)}</span>.<br>`
        + `  Your walk may not be recorded very accurately.`,
      b1: '<button name="showStartNew">Start a walk!</button>',
    }
    populateApp(strings)
    app.style.display = 'block'
  }
  async function goodAccuracyCanWalk(o, g) {
    console.log(`good accuracy: ${g.coords.accuracy}`)
    o.showsUserLocation = true
    o.tracksUserLocation = true
    o.showsUserLocationControl = true
    window.me = new mapkit.Coordinate(g.coords.latitude, g.coords.longitude)
    window.here = new mapkit.CoordinateRegion(
      me,
      new mapkit.CoordinateSpan(0.05, 0.05)
    )
    if (!window._map) {
      window._map = new mapkit.Map('map', o)
    }
    window._map.region = here
    window._map.cameraDistance = 100
    window._map.showsUserLocation = true 
    window._map.setCenterAnimated(me, true)
    myGeocoder(me) 
    const strings = {
      h3: 'Your starting position looks good.',
      p1: `Your position is <span id="lat" class="coords">${g.coords.latitude.toFixed(4)}</span> lat, <span id="lon" class="coords">${g.coords.longitude.toFixed(4)}</span> lon.<br>`,
      p2: '',
      p3: `GPS accuracy is good, <span id="acc" class="coords">${displayUnits(g.coords.accuracy, 'f', 1)}</span>.<br>`
        + '  Tap the start button when you are ready.',
      b1: '<button name="showStartNew">Start a walk!</button>',
    }
    populateApp(strings)
    app.style.display = 'block'
  }
  // Geocoder
  function myGeocoder(coords) {
    console.log('geocoder with: ', coords)
    const opts = {
      getsUserLocation: true,
      language: 'en-US'
    }
    const geocoder = new mapkit.Geocoder(opts)
    console.log(geocoder)
    const reverseLookup = geocoder.reverseLookup(coords, function(error, data) {
      console.log('reverseLookup callbback')
      if (error) {
        console.info(error)
      }
      if (data && data.results.length > 0) {
        console.log(data.results[0])
        populateApp(null, null, data.results[0])
      }
    })
  }
  function displayUnits(x, u = 'm', n = null) {
    if (!x) {
      return null
    }
    const _n = n ?? 1
    if (u === 'm') {
      return `${x.toFixed(_n)} m`
    }
    if (u === 'f') {
      return `${( parseFloat(x) * 3.3 ).toFixed(_n)} ft`
    }
    if (u === 'mi') {
      return `${( parseFloat(x) * 3.3 / 5280 ).toFixed(_n)} mi`
    }
  }
  function populateApp(strings, coords = null, locality = null) {
    const a = window.app ?? document.querySelector('div#app')    
    // console.log(a)
    if (strings) {
      a.children.namedItem('h3').innerHTML = strings.h3
      a.children.namedItem('p1').innerHTML = strings.p1
      a.children.namedItem('p2').innerHTML = strings.p2
      a.children.namedItem('p3').innerHTML = strings.p3
      if (strings?.b1) {
        const b1div = document.createElement('div')
        b1div.innerHTML = strings.b1
        a.appendChild(b1div)
      }
    }
    if (locality) {
      console.log(`updating new locality: ${(locality?.subLocality) ? locality.subLocality + ',' : ''} ${locality?.name}`) 
      const l = `${(locality?.subLocality) ? '<span id="subLocality">' + locality.subLocality + '</span><br>' : ''}`
        + `${(locality?.name) ? '<span id="name">' + locality.name + '</span><br>' : ''}` 
        + `${(locality?.locality) ? '<span id="locality">' + locality.locality + '</span>, ' : ''}`
        + `${(locality?.administrativeAreaCode) ? '<span id="administrativeAC">' + locality.administrativeAreaCode + '</span>' : ''}`
        + '<br>'
        a.children.namedItem('p2').innerHTML += l
      // new walk div content
      document.querySelector('input[id="name"]').value = (locality?.subLocality) ? locality.subLocality : locality.name
    }
    if (coords) {
      console.log('populateApp coords: ', coords)
      console.log(`updating user's coordinates: (${coords.latitude.toFixed(4)}, ${coords.longitude.toFixed(4)})`)
      const _lat = a.querySelector('p > span#lat')
      if (coords.latitude && _lat) {
        a.querySelector('p > span#lat').innerHTML = coords.latitude.toFixed(4)
      }
      const _lon = a.querySelector('p > span#lon')
      if (coords.longitude && _lon) {
        a.querySelector('p > span#lon').innerHTML = coords.longitude.toFixed(4)
      }
      const _acc = a.querySelector('p > span#acc')
      if (coords.accuracy && _acc) {
        a.querySelector('p > span#acc').innerHTML = displayUnits(coords.accuracy, 'f', 1)
      }
      // new walk div content
      document.querySelector('input[id="lat"]').value = coords.latitude ?? ''
      document.querySelector('input[id="lon"]').value = coords.longitude ?? ''
    }
  }
  await main()
</script>
